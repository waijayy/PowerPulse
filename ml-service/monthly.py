# -*- coding: utf-8 -*-
"""monthly.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y82gadc4g1nEfB5PzVQ63solJRoqWreQ
"""

import pandas as pd
import numpy as np
import os
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
import matplotlib.pyplot as plt

# --------------------------
# CONFIG
# --------------------------
REAL_DATA_PATH = 'House_4.csv'
SYNTHETIC_DATA_PATH = 'House_4_Demo (1).csv'
FREQ = 'D'
LOOK_BACK_STEPS = 60
FORECAST_STEPS = 180

# --------------------------
# DATA PROCESSING
# --------------------------
def load_and_resample(filepath, freq='D'):
    if not os.path.exists(filepath):
        print(f"⚠️ File {filepath} not found. Using Demo file instead if available.")
        filepath = 'House_4_Demo.csv'

    print(f"Loading {filepath}...")
    df = pd.read_csv(filepath)
    df['Time'] = pd.to_datetime(df['Time'], errors='coerce')
    df.dropna(subset=['Time'], inplace=True)
    df.set_index('Time', inplace=True)

    # Resample
    df_resampled = df['Aggregate'].resample(freq).mean().to_frame()

    # Convert Units
    if freq == 'D':
        df_resampled['Aggregate'] = (df_resampled['Aggregate'] * 24) / 1000.0 # kWh/day
    elif freq == 'H':
        df_resampled['Aggregate'] = df_resampled['Aggregate'] / 1000.0 # kWh/hour

    df_resampled['Aggregate'] = df_resampled['Aggregate'].interpolate(method='linear', limit=2)
    df_resampled.dropna(inplace=True)

    # Feature Engineering (MUST MATCH indices in recursive_forecast)
    # Index 0: Aggregate
    # Index 1: month_sin
    # Index 2: month_cos
    df_resampled['month_sin'] = np.sin(2 * np.pi * df_resampled.index.month / 12)
    df_resampled['month_cos'] = np.cos(2 * np.pi * df_resampled.index.month / 12)

    return df_resampled

def create_sequences(data, look_back):
    X, y = [], []
    for i in range(len(data) - look_back):
        X.append(data[i:(i + look_back)])
        y.append(data[i + look_back, 0])
    return np.array(X), np.array(y)

# --------------------------
# MODEL BUILDING
# --------------------------
def build_model(input_shape):
    model = Sequential()
    model.add(LSTM(64, input_shape=input_shape, return_sequences=False))
    model.add(Dropout(0.2))
    model.add(Dense(1))
    model.compile(optimizer='adam', loss='mse')
    return model

# --------------------------
# FORECASTING LOOP
# --------------------------
def recursive_forecast(model, initial_sequence, steps, scaler, start_date):
    """
    Predicts recursively, UPDATING time features each step to capture seasonality.
    """
    forecast = []
    current_seq = initial_sequence.copy()
    current_date = start_date

    print(f"Generating {steps} step forecast starting from {start_date}...")

    for i in range(steps):
        # 1. Predict next value
        input_seq = current_seq[np.newaxis, :, :]
        pred_value_normalized = model.predict(input_seq, verbose=0)[0, 0]
        forecast.append(pred_value_normalized)

        # 2. Advance time by 1 day
        current_date = current_date + pd.Timedelta(days=1)

        # 3. Create next input row with UPDATED time features
        next_row = current_seq[-1].copy()

        # Update Target (Aggregate Power) - Index 0
        next_row[0] = pred_value_normalized

        # Update Time Features - Indices 1 & 2 (Must match load_and_resample order)
        # We need to re-calculate these based on the new 'current_date'
        next_row[1] = np.sin(2 * np.pi * current_date.month / 12) # month_sin
        next_row[2] = np.cos(2 * np.pi * current_date.month / 12) # month_cos

        # 4. Slide window
        current_seq = np.vstack([current_seq[1:], next_row])

    # Inverse transform
    dummy_array = np.zeros((len(forecast), current_seq.shape[1]))
    dummy_array[:, 0] = forecast
    inverse_forecast = scaler.inverse_transform(dummy_array)[:, 0]

    return inverse_forecast

# --------------------------
# MAIN WORKFLOW
# --------------------------
if __name__ == "__main__":
    # 1. Load Data
    print("--- 1. Processing Training Data ---")
    real_df = load_and_resample(REAL_DATA_PATH, freq=FREQ)

    scaler = MinMaxScaler(feature_range=(0, 1))
    scaled_train = scaler.fit_transform(real_df.values)

    X_train, y_train = create_sequences(scaled_train, LOOK_BACK_STEPS)

    # 2. Train
    print("--- 2. Training LSTM Model ---")
    model = build_model((X_train.shape[1], X_train.shape[2]))
    model.fit(X_train, y_train, epochs=30, batch_size=16, validation_split=0.1, verbose=1)

    # 3. Forecast Setup
    print("\n--- 3. Forecasting ---")
    synth_df = load_and_resample(SYNTHETIC_DATA_PATH, freq=FREQ)
    scaled_synth = scaler.transform(synth_df.values)

    initial_seq = scaled_synth[-LOOK_BACK_STEPS:]
    last_date = synth_df.index[-1]

    # Get daily predictions first
    daily_predictions = recursive_forecast(model, initial_seq, FORECAST_STEPS, scaler, start_date=last_date)

    # ---------------------------------------------------------
    # NEW STEP: AGGREGATE TO MONTHLY TOTALS
    # ---------------------------------------------------------
    # Create dates for the forecast
    future_dates = pd.date_range(start=last_date + pd.Timedelta(days=1), periods=FORECAST_STEPS, freq='D')

    # Create a DataFrame
    forecast_df = pd.DataFrame({'Date': future_dates, 'Daily_kWh': daily_predictions})

    # Group by Month and Sum the energy
    # 'ME' means Month End frequency
    monthly_totals = forecast_df.resample('ME', on='Date')['Daily_kWh'].sum()

    # Filter to exclude the 7th month (June) and only show Dec 2025 - May 2026
    monthly_totals = monthly_totals.iloc[:6]

    print("\n" + "="*40)
    print("   FORECASTED ENERGY USAGE (Next 6 Months)")
    print("="*40)
    for date, value in monthly_totals.items():
        print(f" {date.strftime('%B %Y')}:  {value:.2f} kWh")
    print("="*40)

    # 4. Simple Bar Chart Visualization
    plt.figure(figsize=(10, 6))

    # Create labels like "Jan 2025"
    labels = [date.strftime('%b %Y') for date in monthly_totals.index]

    bars = plt.bar(labels, monthly_totals.values, color='cornflowerblue', edgecolor='black')

    # Add value labels on top of bars
    for bar in bars:
        height = bar.get_height()
        plt.text(bar.get_x() + bar.get_width()/2., height,
                 f'{height:.0f}',
                 ha='center', va='bottom')

    plt.title('Predicted Total Energy Usage per Month')
    plt.ylabel('Total Energy (kWh)')
    plt.xlabel('Month')
    plt.grid(axis='y', linestyle='--', alpha=0.5)
    plt.show()